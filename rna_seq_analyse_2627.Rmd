---
title: "Analyse van RNA-seq data"
author: "Groep_1"
date: "`r Sys.Date()`"
output: html_document
---

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

```{r, eval=TRUE, warning=FALSE, message=FALSE}
library(tidyverse)
library(Rsubread)
library(DESeq2)
library(GOstats)
```

--------------------------------------------------------------------------------
# Introductie

In dit project wordt onderzocht welke genen verschillend tot expressie komen tussen hersenweefsel en leverweefsel. De onderzoeksvraag luidt: welke verschillen in genexpressie zijn aanwezig tussen hersen- en leverweefsel en welke biologische processen hangen hiermee samen?

Om deze vraag te beantwoorden wordt RNA-seq data geanalyseerd. De reads worden uitgelijnd tegen een referentiegenoom en samengevat in een counttabel, waarna een differentiële genexpressieanalyse wordt uitgevoerd. Vervolgens wordt een GO-term enrichment analyse toegepast om inzicht te krijgen in de biologische functies en processen die samenhangen met de gevonden expressieverschillen.

<br>

```{R}
# deze code zorgt ervoor dat er een standaard folder gemaakt word die gebruikt kan worden voor alle code zodat alle data altijd op de juiste plek zit. verder doet download de code ook meteen alle files die gebruikt worden zodat je dat zelf ook niet hoeft te doen.

project_dir <- file.path(Sys.getenv("HOME"), "project")
# deze code maakt een standaard pat naar de folder die ook meteen word gemaakt

data_dir <- file.path(project_dir, "data", "raw")
bam_dir <- file.path(project_dir, "data", "bam")
index_dir <- file.path(project_dir,"index")
# de _dir code's maken routes naar specific tabs in de folders zodat alles meteen netjes op zijn eigen plek kan belanden.

make_dir <- function(x) {
  if (!dir.exists(x)) dir.create(x, recursive = T)}
make_dir(data_dir)
make_dir(bam_dir)
make_dir(index_dir)
# deze functie maakt de folders aan volgens de route die eerder gemaakt is als die nog niet bestaan, maar als ze al bestaan dan gebeurd dat niet.

fastq_dest <- file.path(project_dir, "data", "raw")
index_dest <- file.path(project_dir, "index")
# de _dest code's worden gebruikt om aan te geven waar de data als die gecopied is naar toe moet.

fastq_src <- "/home/data/opra4v/fastq/"
index_src <- "/home/data/opra4v/hg38_index/"
# de _srx code's geven de locaties die waar de files vandaan worden gedownload.

if (!dir.exists(fastq_dest)) {
  file.copy(fastq_src, fastq_dest, recursive = T)} 
if (!dir.exists(index_dest)) {
  file.copy(index_src, index_dest, recursive = T)}
# de copy functie copied de code van de locatie die wordt aangegeven met de _src code en plakt het op de locatie die wordt aangegeven met _dest en de recursive wordt gebruikt om er voor te zorgen dat als die bestanden er al zijn dat die dan niet nog een keer worden gecopied.
```

# Alignment

Voor de alignment zijn de FASTQ-bestanden van lever- en hersenweefsel uitgelijnd tegen het humane referentiegenoom hg38 met de functie align() uit het Rsubread pakket. Hiervoor is een vooraf gegenereerde hg38-index gebruikt. De zes FASTQ-bestanden (drie lever en drie brein) zijn meegegeven via readfile1, zodat elke sample apart wordt uitgelijnd.

Omdat het om RNA-seq data gaat, is type = 0 ingesteld zodat het juiste mappingprotocol voor RNA wordt toegepast. De inputbestanden zijn gzipped FASTQ-bestanden (input_format = "gzFASTQ") en de resultaten zijn opgeslagen als BAM-bestanden (output_format = "BAM").

Met unique = TRUE zijn alleen reads meegenomen die op één duidelijke plek in het genoom mappen. Reads die op meerdere locaties kunnen mappen zijn uitgesloten, zodat elke read eenduidig wordt toegewezen. De alignment statistieken zijn opgeslagen in het object alignment_statistics voor verdere analyse.

Het is uitgesloten om abiquiteit (op het meerdere passen van de sequencing reads) te verminderen zodat elke read eenduidig toegewezen wordt. multi mapping reads kunnen onzzekerheid veroorzaken in de kwantificatie. van gen expressie. Aligner weet dan niet op welke plek de read echt hoort. Door uitsluitend unique gemapte reads te behouden wordt de betrouwbaarheid van downstream analyse verhoogd.

## Uitvoering van alignment

```{R}
alignment_statistics <- align(
  
  index = "~/project/index/hg38_index/hg38_index" , 
  # character string met de basisnaam van het indexbestand van het referentiegenoom, dat zich in     de huidige directory moet bevinden. Deze index is nodig om reads aan hun mogelijke positie      in het genoom te koppelen.
  
  readfile1 = file.path("~/project/data/raw/fastq/", c( "SRR7961208.fastq.gz", "SRR7961209.fastq.gz", "SRR7961210.fastq.gz", "SRR7961214.fastq.gz", "SRR7961215.fastq.gz", "SRR7961216.fastq.gz")) , 
  # character vector met bestandsnamen van bestanden met sequentiereads. Bij paired-end             sequencing bevat dit de eerste reads van elk paar.
  
  type = 0, 
  # character string of een integer die het type sequencing data geeft om zo te bepalen welk        mapping protocol gebruikt moet worden. (0 voor rna, 1 voor dna).
  
  input_format = "gzFASTQ", 
  # character string van het format van de inputreads (bijv. FASTQ, gzFASTQ, BAM), bepaalt hoe      de functie het bestand moet inlezen.
  
  output_format = "BAM", 
  # character string van het format van de output (aligned reads), bepaalt in welk type bestand     (BAM/SAM) de aligner de resultaten opslaat.
  
  output_file = file.path( "~/project/data/bam/", c(
    "liver_1.bam", "liver_2.bam", "liver_3.bam",
  "brain_1.bam", "brain_2.bam", "brain_3.bam")), 
  # character vector die aangeeft wat de naam/namen van de output bestanden zijn. (standaard        afgeleid van bestandsnamen uit readfile1 met een extra suffix).
  
  unique = T , 
  # bepaalt of alleen uniek gemapte reads worden gerapporteerd. Bij TRUE worden alleen reads met     één beste mappinglocatie meegenomen, bij FALSE ook reads met meerdere mogelijke mappings.
  
  nthreads = 30 
  # aantal CPU-kernen die tegelijk gebruikt mogen worden, meer threads = sneller alignen door       parallel werken. standaardwaarde is 1.
)
```
 
## Analyse van de alignment statistieken

```{r fig.cap="Figuur 1: Uniek gemapte reads per BAM bestand voor brein- en lever weefsel."}
# berekenen van het percentage uniquely mapped reads per BAM file
unique_reads <- alignment_statistics["Uniquely_mapped_reads", ]
total_reads <- alignment_statistics["Total_reads", ]
percent_unique <- (unique_reads / total_reads) * 100

# maken van een dataframe voor de staafdiagram van uniquely mapped reads per BAM file
bam_files <- colnames(alignment_statistics)

tissue <- ifelse(grepl("liver", bam_files), "Lever", "Brein")

alignment_df <- data.frame(
  BAM = bam_files,
  PercentUnique = as.numeric(percent_unique),
  Tissue = tissue
)
  
# maken van de staafdiagram
bam_staafdiagram <- ggplot(alignment_df, aes(x = BAM, y = PercentUnique, fill = Tissue)) +
  geom_col() +
  labs(
    title = "Percentage uniek gemapte reads per BAM bestand",
    x = "BAM bestand",
    y = "Percentage uniek gemapte reads (%)",
    fill = "Weefsel"
  ) +
  theme_minimal() 

bam_staafdiagram
```
In figuur 1 zijn per BAM bestand het percentage uniek gemapte reads te zien. Hierbij valt op dat de percentages tussen de twee weefsels verschillen. De levermonsters laten waarden zien tussen ongeveer 49% en 78%, terwijl de hersenmonsters waarden laten zien tussen ongeveer 28% tot 66%. Daarnaast is binnen beide weefseltypes spreiding tussen replicaten zichtbaar.

## Conclusie van de alignmentstatistieken

Uit de alignment statistieken blijkt dat het percentage uniek gemapte reads verschilt tussen de verschillende BAM-bestanden. Zowel binnen de lever- als de breinmonsters is spreiding zichtbaar. Een paar samples hebben een duidelijk lager percentage dan andere. Dit laat zien dat de alignmentkwaliteit niet voor alle monsters gelijk is.

--------------------------------------------------------------------------------

# Count tabel en data inspectie

```{R}
read_counts <- featureCounts(
  
  files = file.path( "~/project/data/bam/", c("liver_1.bam", "liver_2.bam", "liver_3.bam",
  "brain_1.bam", "brain_2.bam", "brain_3.bam")), 
  # character vector die de naam/namen van het bestand/de bestanden met de uitgelijnde reads geeft. (BAM/SAM, bestandtype wordt automatisch gedetecteerd).
  
  annot.inbuilt =  "hg38", 
  # character string die aangeeft welke ingebouwde genannotatie wordt gebruikt bij het samenvatten van reads. De waarde bepaalt voor welk organisme en genoomversie de annotatie geldt, met mm39 als standaard. In het geval van deze analyse wordt hg38 gebruikt.
  
  useMetaFeatures = T , 
  # indicator voor op welk niveau reads worden samengevat. Bij TRUE gebeurt dit op meta-feature niveau zoals genen, bij FALSE op feature-niveau zoals exons. In het geval van deze analyse is het TRUE.
  
  strandSpecific = 0 , 
  # Integer vector die bepaalt of en hoe rekening wordt gehouden met de strandrichting bij het tellen van reads. Waarde 0 betekent geen strand-specifieke telling, 1 telt reads in dezelfde richting als de annotatie en 2 in de omgekeerde richting. Standaard wordt 0 gebruikt.
  
  isPairedEnd = F ,
  # logical vector die aangeeft of de gebruikte libraries paired-end reads bevatten. FALSE betekent single-end data. Deze instelling bepaalt samen met countReadPairs of reads per paar of afzonderlijk worden geteld.
  
  nthreads = 30 
  # aantal CPU-kernen die tegelijk gebruikt mogen worden, meer threads = sneller alignen door parallel werken. standaardwaarde is 1.
)
```

--------------------------------------------------------------------------------

# DGE analyse

```{r, eval=TRUE}
# uitvoeren van de DESeq2 analyse, waarbij size factors en dispersies worden geschat en een negatief binomiaal model wordt toegepast op de ruwe countdata
dge <- DESeq(
    
    object = ............... , # het DESeqDataSet object dat de input vormt voor de DESeq2 analyse.
)
```

--------------------------------------------------------------------------------

# GO-term analyse

```{r, eval=TRUE}
test_object <- new(
    
    "GOHyperGParams",
    
    geneIds = ............... , # numeric of character vector met de gene IDs van de genen die geselecteerd zijn voor de analyse.
    
    universeGeneIds = ............... , # vector van gene IDs in hetzelfde format als geneIds die bepaalt welke genen als achtergrond worden gebruikt bij de statistische toets. Als deze leeg is, worden alle genen meegenomen.
    
    annotation = ............... , # string met de naam van het annotatiepakket dat hoort bij de chip waarmee de data is gegenereerd.
)
```

# Conclusie

# Discussie