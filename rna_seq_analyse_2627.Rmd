---
title: "Analyse van RNA-seq data"
author: "Chelaysiah Steba"
date: "`r Sys.Date()`"
output: html_document
---

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

```{r, eval=TRUE, warning=FALSE, message=FALSE}
library(tidyverse)
library(Rsubread)
library(DESeq2)
library(GOstats)
library(pheatmap)
```

--------------------------------------------------------------------------------
# Introductie

In dit project wordt onderzocht welke genen verschillend tot expressie komen tussen hersenweefsel en leverweefsel. De onderzoeksvraag luidt: welke verschillen in genexpressie zijn aanwezig tussen hersen- en leverweefsel en welke biologische processen hangen hiermee samen?

Om deze vraag te beantwoorden wordt RNA-seq data geanalyseerd. De reads worden uitgelijnd tegen een referentiegenoom en samengevat in een counttabel, waarna een differentiële genexpressieanalyse wordt uitgevoerd. Vervolgens wordt een GO-term enrichment analyse toegepast om inzicht te krijgen in de biologische functies en processen die samenhangen met de gevonden expressieverschillen.

<br>

# Alignment

Voor de alignment zijn de FASTQ-bestanden van lever- en hersenweefsel uitgelijnd tegen het humane referentiegenoom hg38 met de functie align() uit het Rsubread pakket. Hiervoor is een vooraf gegenereerde hg38-index gebruikt. De zes FASTQ-bestanden (drie lever en drie brein) zijn meegegeven via readfile1, zodat elke sample apart wordt uitgelijnd.

Omdat het om RNA-seq data gaat, is type = 0 ingesteld zodat het juiste mappingprotocol voor RNA wordt toegepast. De inputbestanden zijn gzipped FASTQ-bestanden (input_format = "gzFASTQ") en de resultaten zijn opgeslagen als BAM-bestanden (output_format = "BAM").

Met unique = TRUE zijn alleen reads meegenomen die op één duidelijke plek in het genoom mappen. Reads die op meerdere locaties kunnen mappen zijn uitgesloten, zodat elke read eenduidig wordt toegewezen. De alignment statistieken zijn opgeslagen in het object alignment_statistics voor verdere analyse.


## Uitvoering van alignment

```{R}
alignment_statistics <- align(
  
  index = "hg38_index/hg38_index" , # character string met de basisnaam van het indexbestand van het referentiegenoom, dat zich in de huidige directory moet bevinden. Deze index is nodig om reads aan hun mogelijke positie in het genoom te koppelen.
  
  readfile1 = file.path("raw_fastq", c( "liver_1.fastq.gz", "liver_2.fastq.gz", "liver_3.fastq.gz", "brain_1.fastq.gz", "brain_2.fastq.gz", "brain_3.fastq.gz" )) , # character vector met bestandsnamen van bestanden met sequentiereads. Bij paired-end sequencing bevat dit de eerste reads van elk paar.
  
  type = 0 , # character string of een integer die het type sequencing data geeft om zo te bepalen welk mapping protocol gebruikt moet worden. (0 voor rna, 1 voor dna).
  
  input_format = "gzFASTQ" , # character string van het format van de inputreads (bijv. FASTQ, gzFASTQ, BAM), bepaalt hoe de functie het bestand moet inlezen.
  
  output_format = "BAM" , # character string van het format van de output (aligned reads), bepaalt in welk type bestand (BAM/SAM) de aligner de resultaten opslaat.
  
  output_file = c(
    "liver_1.bam",
  "liver_2.bam",
  "liver_3.bam",
  "brain_1.bam",
  "brain_2.bam",
  "brain_3.bam"
  ) , # character vector die aangeeft wat de naam/namen van de output bestanden zijn. (standaard afgeleid van bestandsnamen uit readfile1 met een extra suffix).
  
  unique = TRUE , # bepaalt of alleen uniek gemapte reads worden gerapporteerd. Bij TRUE worden alleen reads met één beste mappinglocatie meegenomen, bij FALSE ook reads met meerdere mogelijke mappings.
  
  nthreads = 2 # aantal CPU-kernen die tegelijk gebruikt mogen worden, meer threads = sneller alignen door parallel werken. standaardwaarde is 1.
  
)
```
 
## Analyse van de alignment statistieken

```{r fig.cap="Figuur 1: Uniek gemapte reads per BAM bestand voor brein- en lever weefsel."}
# berekenen van het percentage uniquely mapped reads per BAM file
unique_reads <- alignment_statistics["Uniquely_mapped_reads", ]
total_reads <- alignment_statistics["Total_reads", ]
percent_unique <- (unique_reads / total_reads) * 100

# maken van een dataframe voor de staafdiagram van uniquely mapped reads per BAM file

bam_files <- colnames(alignment_statistics)

tissue <- ifelse(grepl("liver", bam_files), "Lever", "Brein") # Labelt bestanden als 'Lever' als 'liver' in de bestandsnaam voorkomt, anders 'Brein'

alignment_df <- data.frame(
  BAM = bam_files,
  PercentUnique = as.numeric(percent_unique),
  Tissue = tissue
)
  
# maken van de staafdiagram
bam_staafdiagram <- ggplot(alignment_df, aes(x = BAM, y = PercentUnique, fill = Tissue)) +
  geom_col() +
  labs(
    title = "Percentage uniek gemapte reads per BAM bestand",
    x = "BAM bestand",
    y = "Percentage uniek gemapte reads",
    fill = "Weefsel"
  ) +
  theme_minimal() 

# staafdiagram opslaan in map van results
ggsave(
  filename = "results/bam_staafdiagram.png",
  plot = bam_staafdiagram,
  width = 8,
  height = 6
)

# tonen staafdiagram
bam_staafdiagram
```
In figuur 1 zijn per BAM bestand het percentage uniek gemapte reads te zien. Hierbij valt op dat de percentages tussen de twee weefsels verschillen. De levermonsters laten waarden zien tussen ongeveer 49% en 78%, terwijl de hersenmonsters waarden laten zien tussen ongeveer 28 tot 66%. Daarnaast is binnen beide weefseltypes spreiding tussen replicaten zichtbaar.

## Conclusie van de alignmentstatistieken

Uit de alignment statistieken blijkt dat het percentage uniek gemapte reads verschilt tussen de verschillende BAM-bestanden. Zowel binnen de lever- als de breinmonsters is spreiding zichtbaar. Een paar samples hebben een duidelijk lager percentage dan andere.

------------------------------------------------------------------------------

# Count tabel en data inspectie
### korte toelichting voor de analyses en verantwoord de gebruikte R code

## Genereren van count table

```{R}
# Genereren van een count-table
read_counts <- featureCounts(
  
  files = file.path("aligned_bam", c( "liver_1.bam", "liver_2.bam", "liver_3.bam", "brain_1.bam", "brain_2.bam", "brain_3.bam" )) , # character vector die de naam/namen van het bestand/de bestanden met de uitgelijnde reads geeft. (BAM/SAM, bestandtype wordt automatisch gedetecteerd).
  
  annot.inbuilt = "hg38" , # character string die aangeeft welke ingebouwde genannotatie wordt gebruikt bij het samenvatten van reads. De waarde bepaalt voor welk organisme en genoomversie de annotatie geldt, met mm39 als standaard. In het geval van deze analyse wordt hg38 gebruikt.
  
  useMetaFeatures = TRUE , # indicator voor op welk niveau reads worden samengevat. Bij TRUE gebeurt dit op meta-feature niveau zoals genen, bij FALSE op feature-niveau zoals exons. In het geval van deze analyse is het TRUE.
  
  strandSpecific = 0 , # Integer vector die bepaalt of en hoe rekening wordt gehouden met de strandrichting bij het tellen van reads. Waarde 0 betekent geen strand-specifieke telling, 1 telt reads in dezelfde richting als de annotatie en 2 in de omgekeerde richting. Standaard wordt 0 gebruikt.
  
  isPairedEnd = FALSE , # logical vector die aangeeft of de gebruikte libraries paired-end reads bevatten. FALSE betekent single-end data. Deze instelling bepaalt samen met countReadPairs of reads per paar of afzonderlijk worden geteld.
  
  nthreads = 2 # aantal CPU-kernen die tegelijk gebruikt mogen worden, meer threads = sneller alignen door parallel werken. standaardwaarde is 1.
)
```

## Omzetten van de count tabel naar een DESeqDataSet

```{r}

# Countmatrix uit list halen
countDatamatrix <- read_counts$counts

# Metadata maken/definieren
metadata_coldata <- data.frame(
  row.names = colnames(countDatamatrix),
  weefsel = c("Lever", "Lever", "Lever", "Brein", "Brein", "Brein")
)

DESeqDataSetFromMatrix(
  countData = countDatamatrix, # De count tabel in de vorm van een matrix
  colData = metadata_coldata, # De metadata van de count tabel in de vorm van een dataframe, zodat voor elk sample aangegeven wordt uit welk weefsel deze afkomstig is.
  design = ~ weefsel # Een formule die aangeeft welk verschil er getest moet worden, in dit geval is dat verschil: type weefsel.
)
```

## Data inspectie mbv correlatieheatmap en PCA

```{r}
# Data inspectie dmv PCA
```

```{r}
# Data inspectie dmv correlatieheatmap
```

## Conclusie van de correlatieheatmap en PCA
--------------------------------------------------------------------------------

# DGE analyse

```{r, eval=TRUE}
# uitvoeren van de DESeq2 analyse, waarbij size factors en dispersies worden geschat en een negatief binomiaal model wordt toegepast op de ruwe countdata
dge <- DESeq(
    
    object = ............... , # het DESeqDataSet object dat de input vormt voor de DESeq2 analyse.
)
```

--------------------------------------------------------------------------------

# GO-term analyse

```{r, eval=TRUE}
test_object <- new(
    
    "GOHyperGParams",
    
    geneIds = ............... , # numeric of character vector met de gene IDs van de genen die geselecteerd zijn voor de analyse.
    
    universeGeneIds = ............... , # vector van gene IDs in hetzelfde format als geneIds die bepaalt welke genen als achtergrond worden gebruikt bij de statistische toets. Als deze leeg is, worden alle genen meegenomen.
    
    annotation = ............... , # string met de naam van het annotatiepakket dat hoort bij de chip waarmee de data is gegenereerd.
)
```

# Conclusie

# Discussie